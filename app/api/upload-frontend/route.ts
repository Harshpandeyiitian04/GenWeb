import { NextResponse } from 'next/server';
import { Octokit } from '@octokit/rest';
import { google } from 'googleapis';
import { drive_v3 } from 'googleapis/build/src/apis/drive/v3';
import path from 'path';

// Constants and configuration
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const GITHUB_USERNAME = 'GenWeb-ai';
const FOLDER_ID = "1CyMqdVSFra-um6lVY3V02t35_JfOPgrc";

// Type definitions
interface FileResponse {
  files: string[];
  repoName: string;
  previewUrl: string;
  categorizedFiles: CategorizedFiles;
  structureDescription?: string;
  repoUrl: string;
}

interface FileContent {
  [key: string]: string;
}

interface CategorizedFiles {
  html: { [key: string]: string };
  css: { [key: string]: string };
  js: { [key: string]: string };
  py: { [key: string]: string };
}

interface ProjectFiles {
  fileStruct?: drive_v3.Schema$File;
  code?: drive_v3.Schema$File;
  readme?: drive_v3.Schema$File;
}

// Initialize Octokit
const octokit = new Octokit({ auth: GITHUB_TOKEN });

// Initialize Google Drive API
const auth = new google.auth.GoogleAuth({
  keyFilename: process.env.GOOGLE_APPLICATION_CREDENTIALS,
  scopes: [
    'https://www.googleapis.com/auth/drive.readonly',
    'https://www.googleapis.com/auth/documents.readonly'
  ],
});

const driveService = google.drive({ version: 'v3', auth });
const docsService = google.docs({ version: 'v1', auth });

// Helper functions
function log(message: string, data?: any) {
  const timestamp = new Date().toISOString();
  console.log(`[${timestamp}] ${message}`);
  if (data) console.log(JSON.stringify(data, null, 2));
}

function cleanStructureDescription(description: string): string {
  return description
    .replace(/[*#`]/g, '') // Only remove *, #, and ` characters
    .trim();
}

function getFileType(filename: string): keyof CategorizedFiles | null {
  const ext = path.extname(filename).toLowerCase();
  switch (ext) {
    case '.html': return 'html';
    case '.css': return 'css';
    case '.js':
    case '.jsx':
    case '.ts':
    case '.tsx': return 'js';
    case '.py': return 'py';
    default: return null;
  }
}

async function readFileContent(fileId: string, mimeType: string): Promise<string> {
  try {
    if (mimeType === 'application/vnd.google-apps.document') {
      const doc = await docsService.documents.get({ documentId: fileId });
      return doc.data.body?.content?.reduce((text, element) => {
        if (element.paragraph) {
          return text + element.paragraph.elements?.reduce((str, el) => 
            str + (el.textRun?.content || ''), '');
        }
        return text;
      }, '') || '';
    } else {
      const response = await driveService.files.get(
        { fileId, alt: 'media' },
        { responseType: 'text' }
      );
      
      if (typeof response.data === 'string') {
        return response.data;
      } else if (response.data && typeof response.data === 'object') {
        return JSON.stringify(response.data);
      } else {
        throw new Error('Invalid response data type');
      }
    }
  } catch (error) {
    log('Error reading file content:', error);
    throw new Error('Failed to read file content');
  }
}

function extractCodeBlocks(content: string): FileContent {
  const fileContent: FileContent = {};
  const pattern = /---\n@\$\s*(.*?)\n```.*?\n([\s\S]*?)```/g;
  let match;

  while ((match = pattern.exec(content)) !== null) {
    const [, filePath, code] = match;
    if (code.trim()) {
      const cleanPath = filePath.trim().replace(/^(frontend\/src\/|frontend\/|src\/)/, '');
      fileContent[cleanPath] = code.trim();
    }
  }

  return fileContent;
}

function categorizeFiles(fileContents: FileContent): CategorizedFiles {
  const categorized: CategorizedFiles = {
    html: {},
    css: {},
    js: {},
    py: {}
  };

  for (const [filePath, content] of Object.entries(fileContents)) {
    const fileType = getFileType(filePath);
    if (fileType) {
      categorized[fileType][filePath] = content;
    }
  }

  return categorized;
}

// GitHub functions
async function createGithubRepo(repoName: string, githubUsername: string): Promise<string> {
  try {
    const response = await octokit.repos.createForAuthenticatedUser({
      name: repoName,
      private: false,
      auto_init: false,
      description: 'Generated by GenWeb-ai',
    });

    return response.data.html_url;
  } catch (error) {
    log('Error creating GitHub repository:', error);
    throw new Error('Failed to create GitHub repository');
  }
}

async function uploadFileToGithub(
  repoName: string,
  filePath: string,
  content: string,
  githubUsername: string
): Promise<void> {
  try {
    await octokit.repos.createOrUpdateFileContents({
      owner: githubUsername,
      repo: repoName,
      path: filePath,
      message: `Add ${filePath}`,
      content: Buffer.from(content).toString('base64'),
      branch: 'main'
    });
  } catch (error) {
    log(`Error uploading file ${filePath}:`, error);
    throw new Error(`Failed to upload ${filePath}`);
  }
}

async function enableGithubPages(repoName: string, githubUsername: string): Promise<void> {
  try {
    await octokit.repos.createPagesSite({
      owner: githubUsername,
      repo: repoName,
      source: {
        branch: 'main',
        path: '/'
      }
    });
  } catch (error) {
    log('Error enabling GitHub Pages:', error);
    // Don't throw error as this is not critical
  }
}

async function findProjectFiles(baseName: string): Promise<ProjectFiles> {
  try {
    const response = await driveService.files.list({
      q: `'${FOLDER_ID}' in parents and name contains '${baseName}' and trashed = false`,
      fields: 'files(id, name, mimeType)',
    });

    const files = response.data.files || [];
    const projectFiles: ProjectFiles = {};

    files.forEach(file => {
      if (!file.name) return;
      
      const lowerName = file.name.toLowerCase();
      
      if (lowerName.includes('file struct:') || lowerName.includes('file_struct:')) {
        projectFiles.fileStruct = file;
      } 
      else if (lowerName.includes('code:')) {
        projectFiles.code = file;
      }
      else if (lowerName.includes('readme:')) {
        projectFiles.readme = file;
      }
    });

    return projectFiles;
  } catch (error) {
    log('Error finding project files:', error);
    throw new Error('Failed to find project files');
  }
}

async function uploadFiles(repoName: string, categorizedFiles: CategorizedFiles, githubUsername: string) {
  for (const [, files] of Object.entries(categorizedFiles)) {
    for (const [filePath, content] of Object.entries(files)) {
      if (typeof content === 'string') {
        await uploadFileToGithub(repoName, filePath, content, githubUsername);
      } else {
        throw new Error('Content is not a string');
      }
    }
  }
}

// Main API handler
export async function POST(request: Request) {
  try {
    const { fileNames } = await request.json();

    if (!Array.isArray(fileNames) || fileNames.length === 0) {
      return NextResponse.json(
        { error: 'No filenames provided' },
        { status: 400 }
      );
    }

    const baseName = fileNames[0];
    log(`Processing project: ${baseName}`);

    // Find all project files
    const projectFiles = await findProjectFiles(baseName);

    if (!projectFiles.code) {
      return NextResponse.json(
        { error: 'No code file found' },
        { status: 404 }
      );
    }

    // Read code content
    const codeContent = await readFileContent(
      projectFiles.code.id!,
      projectFiles.code.mimeType!
    );

    // Extract and categorize files
    const fileContents = extractCodeBlocks(codeContent);
    const categorizedFiles = categorizeFiles(fileContents);

    // Create GitHub repository
    const timestamp = new Date().getTime();
    const repoName = `${baseName.toLowerCase().replace(/[^a-z0-9-]/g, '-')}-${timestamp}`;
    const repoUrl = await createGithubRepo(repoName, GITHUB_USERNAME);

    // Upload files
    await uploadFiles(repoName, categorizedFiles, GITHUB_USERNAME);

    // Upload README if it exists
    if (projectFiles.readme) {
      const readmeContent = await readFileContent(
        projectFiles.readme.id!,
        projectFiles.readme.mimeType!
      );
      await uploadFileToGithub(repoName, 'README.md', readmeContent, GITHUB_USERNAME);
    }

    // Get structure description if available
    let structureDescription = '';
    if (projectFiles.fileStruct) {
      const structContent = await readFileContent(
        projectFiles.fileStruct.id!,
        projectFiles.fileStruct.mimeType!
      );
      structureDescription = cleanStructureDescription(structContent);
    }

    // Enable GitHub Pages
    await enableGithubPages(repoName, GITHUB_USERNAME);

    // Prepare response
    const response: FileResponse = {
      files: Object.keys(fileContents),
      repoName,
      repoUrl,
      previewUrl: `https://${GITHUB_USERNAME}.github.io/${repoName}`,
      categorizedFiles,
      structureDescription
    };

    log('Successfully processed project', response);
    return NextResponse.json(response);

  } catch (error) {
    log('Error processing request:', error);
    return NextResponse.json(
      { error: `Internal Server Error: ${error instanceof Error ? error.message : String(error)}` },
      { status: 500 }
    );
  }
}

export async function GET() {
  return NextResponse.json({
    message: 'Frontend Code Handler API',
    endpoints: {
      '/api/upload-frontend': 'POST - Process and upload frontend code files'
    }
  });
}